# PySC2

PySC2 - библиотека, созданная компанией DeepMind и предназначеная для написания искустенного интелекта, обучающегося посредством большого количества итераций.


## Окружение (Enviroment)

Полное описание спецификации конфигурации окружения (enviroment), наблюдения (observation) и рабочего пространства можно найти [здесь](https://github.com/deepmind/pysc2/blob/master/docs/environment.md)


## Некоторые особенности Starcraft

### Неопределенность

Starcraft II  почти не имеет рандомных явлений, но у него есть неопределенность, которая определена по косметическим причинам. Двумя основными случайными событиями являются скорость атаки и порядок обновления.

Скорость атаки случайна в из-за задержки юнитов перед выстрелом и составляет от -1 до +2 игровых шагов для почти всех единиц. Идея состоит в том, что группа морпехов может начать стрелять вместе, но задержка +/- для следующего выстрела сделает группу менее роботизированной и предотвратит их синхронную стрельбу. Поэтому справедливый матч (например, 1х1 морпехов) приведет к случайному результату.

Порядок обновления тоже случаен и определяет порядок событий в заданном игровом цикле. Например, если у вас есть два высоких тамплиера, которые бросают обратную связь друг на друга на одном игровом цикле, то заранее неопределено кто нанесет урон первым и выиграет.

Автоматический таргетинг объектов детерминирован, но сложен. Он основан на оценке расстояний стрельбы оружия, угрозы и помощи. Юниты будут считать любых врагов с оружием более приорететными, чем без оружия, и враги, которые могут нанести ответный огонь, будут более приоритетными, чем те, которые не могут. Единицы, которые не могут атаковать этот юнит (например, Ракетная башня против морского пехотинца), но которые атакуют союзную единицу (например, medivac), попросят помощь и увеличат приоритет. Целитель поднимает свой приоритет, когда исцеляет. Если две цели имеют одинаковый приоритет, будет выбран ближайший.

Эта неопределенность может быть убрана или уменьшена путем установки начального значения для генератора псевдослучайных чисел. Повторы работают потому что настройки игры включают начальное значение генератора, а также список действий всех игроков, а затем воспроизводятся действия.


### Расчет APM(Action per minute)

Игра вычисляет APM запутанным способом. Не очевидно, как подсчитать действие перемещения камеры с помощью прокрутки края или сколько действий стоит здание. Вот несколько правил, как это было в игре.

Есть на самом деле два типа сообщается в игре:

 - Действия в минуту (APM): подсчитывает каждое действие.
 - Эффективные действия в минуту (EPM): фильтрует действия которые не имеют никакого влияние (например: повторное выделение).

Различные действия имеют разные коэффициенты:

 - Команды с целью = 2 (например: перемещение, атака, построение здания)
 - Команды без цели = 1 (например: остановка, Железнодорожный блок, выгрузка груза)
 - Smart = 1 (щелкните правой кнопкой мыши)
 - Группы выбора и управления = 1
 - Все остальное = 0 (например: движение камеры)

Пользовательский интерфейс рассчитывает это с двумя различными временными интервалами: средний (средний за всю игру до момента расчета) и текущий (средний за последние 5 секунд). API предоставляет только средний APM.


## Данные наблюдения (Observations)

Starcraft II имеет очень богатое набор действий и множество параметров игрового мира. Игра выводит как пространственные / визуальные  данные, так и структурированные данные игрового мира. Структурированные данные определяют все информативные элементы, расположенные на экране (например колличество минералов),  агенты могут не распознать эти элементы как информацию, особенно при низком разрешении. К тому же трудно воспроизвести повтор в точно таком же формате, что видел человек.

### Примечание

Параметры игрового мира хранятся в координатном пространстве (y, х). Но действия, требующие координату точки на экране или миникарте, ожидают координаты в формате (x, y). Начало координат (0, 0) находится в левом верхнем углу в обоих случаях.

Пример передачи экранной координаты действию (см. в разделе скриптовые агенты):
```python
# Spatial observations have the y-coordinate first:
y, x = (obs.observation["feature_screen"][_PLAYER_RELATIVE] == _PLAYER_NEUTRAL).nonzero()

# Actions expect x-coordinate first:
target = [int(x.mean()), int(y.mean())]
action = actions.FunctionCall.Move_screen("now", target)
```

### Пространственно-визуальные данные

#### RGB-матрица (RGB Pixels)

RGB-матрица доступна как для основной области экрана, так и для мини-карты при выбранном разрешении. Перспектива используется как и на экране у человека, но не включает весь дополнительные декорации вокруг экрана, такие как командная карта, окно выбора, очередь сборки и т. д. Они доступны как `rgb_screen` и `rgb_minimap`.

#### Векторные слои (Feature layers)

Игра также предоставляет векторные слои. Они представляют примерно ту же информацию, что и RGB-матрица,но информация разложена и структурирована. Существует ~25 векторных слоев, включая экран и мини-карту и доступных как `feature_screen` и `feature_minimap`.

Полный список определяется в `pysc2.lib.features`.

##### Миникарта

Векторные слои для миникарты:

 - **height_map** - показывает уровень высоты местности.
 - **visibility** - какая часть карты скрыта, была видна или видна сейчас.
 - **creep** - какие части карты покрыта слизью зерга.
 - **camera** - какая часть карты наблюдается на экране.
 - **player_id** - кто владеет юнитами, возвращает абсолютный идентификатор.
 - **player_relative** - отображает дружелюбность/враждебность юнитов.
 - **selected** - какие юниты выбраны.

 **player_relative** принимает значения в диапазоне [0, 4], которые обозначают [фоновый, самостоятельный, союзный, нейтральный, вражеский] юнит соответственно.

#### Экран

Векторные слои для экрана:

 - **height_map** - показывает уровень высоты местности.
 - **visibility** - какая часть карты скрыта, была видна или видна сейчас.
 - **creep** - какие части карты покрыта слизью зерга.
 - **power** - какие юниты протоссов имеют силу, показывает только вашу силу.
 - **player_id** - кто владеет юнитами, возвращает абсолютный идентификатор.
 - **player_relative** - отображает дружелюбность/враждебность юнитов.
 - **unit_type** - идентификатор типа юнита,
 - **selected** - какие юниты выбраны.
 - **hit_points** - количество хитов у юнитов.
 - **energy** - сколько энергии у юнита.
 - **shields** - прочность щитов у юнита. Только для протоссов.
 - **unit_density** - сколько единиц в этом пикселе.
 - **unit_density_aa** - сглаженная версия **unit_density** с ограничением в 16 единиц на пиксель.

Индентификаторы для **unit_type** можно найти в pysc2/lib/units.py.
**player_relative** принимает такие же значения как и для миникарты в диапазоне [0, 4].
**unit_density_aa** дает вам суб-пикселей расположение и размер. Например, если Единица измерения имеет диаметр ровно 1 пиксель, unit_density будет показывать ее ровно в 1 пиксель, независимо от того, где в этом пикселе она фактически центрирована. unit_density_aa вместо этого скажет вам, сколько каждого пикселя покрыто единицей. Единица измерения, которая меньше пикселя и центрирована в пикселе, будет давать значение меньше, чем максимальное. Единица с диаметром 1, центрированная около угла пикселя, даст примерно четверть его значения каждому из 4 пикселей, которые он покрывает. Если несколько единиц охватывают пиксель, их доля в покрытом пикселе будет суммирована до 256.